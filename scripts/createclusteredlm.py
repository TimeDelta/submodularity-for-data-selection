# coding=utf-8
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# ! IMPORTANT ! Do NOT remove the first line of this file, you will break the code !
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
import sys, re, optparse, os
from collections import defaultdict
from math import log10

from sys import platform as _platform
if _platform == 'win32':
	import winsound


def main():
	rows, columns = os.popen('stty size', 'r').read().split()
	fmt           = optparse.IndentedHelpFormatter(max_help_position=int(columns) - 50, width=int(columns))
	parser        = optparse.OptionParser(usage='', formatter=fmt)
	
	# add options to option parser
	parser.add_option('-c', '--corpus',
	                  help   = 'Corpus file to use. ["corpus"]')
	parser.add_option('-p', '--predefined',
	                  help   = 'File containing pre-defined clusters to use.')
	parser.add_option('-c', '--clusters',
	                  type   = 'int',
	                  help   = 'The number of clusters to use in the clustering algorithm. [1000]')
	parser.add_option('-C', '--check',
	                  action = 'store_true',
	                  help   = 'Check data structures are valid (expensive).')
	parser.add_option('-o', '--output',
	                  help   = 'File name for the resulting ARPA file (writes to <argument>.arpa). ["output"]')
	parser.add_option('-w', '--write-clusters',
	                  action = 'store_true',
	                  help   = 'Write the clusters to a file(<corpus file name>.clusters).')
	parser.add_option('-q', '--quiet',
	                  action = 'store_true',
	                  help   = 'Quiet mode.')
	
	parser.set_defaults(corpus         = 'corpus',
						predefined     = None,
						clusters       = None,
						check          = None,
						output         = 'output',
						write_clusters = None,
						quiet          = None)
	options, args = parser.parse_args()
	
	if options.clusters < 2:
		print 'Sorry, this script requires more than 1 cluster. Please try again.'
		exit()
	
	# get the corpus text
	try:
		input = open(options.input, 'r')
		text  = input.read()
		input.close()
	except IOError:
		print 'Error: Input file does not exist.'
		exit()
	
	predefinedClusters = dict()
	precluster_re = re.compile('^@![a-zA-Z0-9_\']+$')
	if options.predefined:
		word_re        = re.compile('^[a-zA-Z0-9_\']+$')
		classes        = open(options.predefined, 'r')
		currentCluster = ''
		
		for line in classes:
			line = re.sub('\n', '', line)
			if precluster_re.match(line):
				# add a new cluster
				predefinedClusters[line] = []
				currentCluster           = line
			elif word_re.match(line):
				# add new word to current cluster
				predefinedClusters[currentCluster].append(line)
				
				# replace all occurrences of the word with the current cluster name
				text = re.sub('(((?<!\')(?<!@)(?<!!))|^)' + r'\b' + line + r'\b' + '(?!\')', currentCluster, text)
		
		classes.close()
		
		# write to file b/c wcluster takes file input
		tempfile = open('wclustertempfile', 'w')
		tempfile.write(text)
		tempfile.close()
	
	# perform clustering according to current platform
	if _platform == 'win32':
		command = 'wcluster_win'
	elif _platform == 'darwin':
		command = './wcluster_darwin'
	elif _platform == 'linux' or _platform == 'linux2':
		command = './wcluster_linux'
	else:
		print 'Cannot determine correct wcluster executable for current platform. Please specify location:'
	command += ' --ncollocs 0 --text '
	if options.predefined:
		command += 'wclustertempfile'
	else:
		command += options.input
	command += ' --paths temp-paths --c ' + str(options.clusters) + ' --plen ' + str(options.plen)
	command += ' --min-occur ' + str(options.minoccur)
	if options.restrict:
		command += ' --restrict ' + options.restrict
	if options.check == True:
		command += ' --chk'
	os.system(command)
	
	# open the log file (if any)
	log = None
	if options.log:
		if options.directory:
			log = options.directory + options.output + '.log'
		log = open(log, 'w')
	
	# open the paths file generated by wcluster
	input = open('temp-paths', 'r')
	
	# create a dictionary to store the words in each cluster
	clusters = dict()
	
	# report progress if requested
	if options.quiet == False:
		msg = """

**********************************
** Interpreting Cluster Results **
**********************************

"""
		if log:
			log.write(msg + '\n')
		else:
			print msg
	
	# for every line in the paths file
	for line in input:
		line = line.split()
		path = line[0]
		word = line[1]
		
		done = False
		for key, value in clusters.iteritems():
			# if the current cluster's path == the new word's path, add the new word
			# to the current cluster
			if key == path:
				# log progress if requested
				if options.quiet == False:
					msg = 'Merging "' + word + '" with cluster ' + key + ' (# Clusters = ' + str(len(clusters)) + ')'
					if log:
						log.write(msg + '\n')
					else:
						print msg
				
				clusters[key].append(word)
				done = True
				break
		
		if done == False:
			# create a new cluster
			clusters[path] = [word]
			
			# log progress if requested
			if options.quiet == False:
				msg = 'Creating new cluster: ' + path + ': ' + word + ' (# Clusters = ' + str(len(clusters)) + ')'
				if log:
					log.write(msg + '\n')
				else:
					print msg
	
	input.close()
	
	# delete all intermediate files created by wcluster
	os.system('rm -f temp-paths ' + options.input + '.int ' + options.input + '.strdb')
	os.system('rm -rf ' + options.input + '*.out')
	if options.predefined:
		os.system('rm -f wclustertempfile*')
	
	# output the clusters if requested
	if options.wclusters:
		clusterfile = options.output + '.clusters'
		if options.directory:
			clusterfile = options.directory + clusterfile
		clusterfile = open(clusterfile, 'w')
		for cluster, words in clusters.iteritems():
			clusterfile.write(cluster + ':\n----------------\n')
			for word in words:
				clusterfile.write(word + '\n')
			clusterfile.write('\n\n')
	
	# report progress if requested
	if options.quiet == False:
		msg = """

***********************************
** Replacing Words With Clusters **
***********************************

"""
		if log:
			log.write(msg + '\n')
		else:
			print msg
	
	# replace all of the words in the input text with their respective cluster
	for key, value in clusters.iteritems():
		for word in value:
			# log progress if requested
			if options.quiet == False:
				msg = 'Replacing ' + word
				if log:
					log.write(msg + '\n')
				else:
					print msg
			
			if word[0:2] == '@!':
				text = re.sub(word, key, text)
			else:
				text = re.sub('(((?<!\')(?<!@)(?<!!))|^)' + r'\b' + word + r'\b' + '(?!\')', key, text)
	
	# count N-Grams and perform Witten-Bell smoothing
	populateDictionary(text, log, options.quiet)
	estimateProbs(log, options.quiet)
	estimateBOs(log, options.quiet)
	
	# report progress if requested
	if options.quiet == False:
		msg = """

************************
** Expanding Clusters **
************************

"""
		if log:
			log.write(msg + '\n')
		else:
			print msg
	
	# expand cluster n-grams
	newDict = ['dummy', defaultdict(gram), defaultdict(lambda: defaultdict(gram)), defaultdict(lambda: defaultdict(lambda: defaultdict(gram)))]
	for n in range(1,4):
		grams = getGrams(n)
		for entry in grams:
			# get the word list for each cluster in the entry
			words = []
			for cluster in entry.split():
				if clusters.has_key(cluster):
					words.append(clusters[cluster])
				else:
					words.append([cluster])
			
			# replace all predefined clusters in the first word slot
			for word in words[0]:
				if precluster_re.match(word):
					words[0].extend(predefinedClusters[word])
					words[0].remove(word)
			
			# enumerate every possible expansion
			expansions = words[0]
			for i in range(1,n):
				temp = expansions
				expansions = []
				for t in temp:
					for word in words[i]:
						if precluster_re.match(word):
							words[i].extend(predefinedClusters[word])
						else:
							expansions.append(t + ' ' + word)
			
			# set the stats for every expansion
			stats = getGramStats(entry)
			for expansion in expansions:
				expansion = expansion.split()
				n = len(expansion)
				
				if n == 1:
					newDict[n][expansion[0]] = stats
				elif n == 2:
					newDict[n][expansion[0]][expansion[1]] = stats
				elif n == 3:
					newDict[n][expansion[0]][expansion[1]][expansion[2]] = stats
	dictionary = newDict
	
	# output ARPA file
	outputfile = options.output
	if options.directory:
		outputfile = options.directory + outputfile
	printArpa(outputfile + '.arpa')
	
	if log:
		log.close()
	
	# alert user that script has finished by playing sound
	if _platform == 'linux' or _platform == 'linux2':
		try:
			os.sytem('play --no-show-progress --null --channels 1 synth %s sine %f' %(300,2000))
		except:
			sys.stdout.write('\a')
	elif _platform == 'win32':
		winsound.Beep(300, 2000)
	elif _platform == 'darwin':
		os.system('say "finished creating ARPA file"')

if __name__ == '__main__':
	main()
